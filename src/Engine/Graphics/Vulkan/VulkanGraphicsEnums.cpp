#include "VulkanGraphicsEnums.h"

using namespace Seele::Vulkan;
using namespace Seele::Gfx;

VkDescriptorType cast(const Seele::Gfx::SeDescriptorType& descriptorType)
{
	switch (descriptorType)
	{
	case SE_DESCRIPTOR_TYPE_SAMPLER:
		return VK_DESCRIPTOR_TYPE_SAMPLER;
	case SE_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER:
		return VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER;
	case SE_DESCRIPTOR_TYPE_SAMPLED_IMAGE:
		return VK_DESCRIPTOR_TYPE_SAMPLED_IMAGE;
	case SE_DESCRIPTOR_TYPE_STORAGE_IMAGE:
		return VK_DESCRIPTOR_TYPE_STORAGE_IMAGE;
	case SE_DESCRIPTOR_TYPE_UNIFORM_TEXEL_BUFFER:
		return VK_DESCRIPTOR_TYPE_UNIFORM_TEXEL_BUFFER;
	case SE_DESCRIPTOR_TYPE_STORAGE_TEXEL_BUFFER:
		return VK_DESCRIPTOR_TYPE_STORAGE_TEXEL_BUFFER;
	case SE_DESCRIPTOR_TYPE_UNIFORM_BUFFER:
		return VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;
	case SE_DESCRIPTOR_TYPE_STORAGE_BUFFER:
		return VK_DESCRIPTOR_TYPE_STORAGE_BUFFER;
	case SE_DESCRIPTOR_TYPE_UNIFORM_BUFFER_DYNAMIC:
		return VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER_DYNAMIC;
	case SE_DESCRIPTOR_TYPE_STORAGE_BUFFER_DYNAMIC:
		return VK_DESCRIPTOR_TYPE_STORAGE_BUFFER_DYNAMIC;
	case SE_DESCRIPTOR_TYPE_INPUT_ATTACHMENT:
		return VK_DESCRIPTOR_TYPE_INPUT_ATTACHMENT;
#ifdef USE_EXTENSIONS
	case SE_DESCRIPTOR_TYPE_INLINE_UNIFORM_BLOCK_EXT:
		return VK_DESCRIPTOR_TYPE_INLINE_UNIFORM_BLOCK_EXT;
	case SE_DESCRIPTOR_TYPE_ACCELERATION_STRUCTURE_NV:
		return VK_DESCRIPTOR_TYPE_ACCELERATION_STRUCTURE_NV;
#endif
	default:
		break;
	}
	return VK_DESCRIPTOR_TYPE_MAX_ENUM;
}

Seele::Gfx::SeDescriptorType cast(const VkDescriptorType& descriptorType)
{
	switch (descriptorType)
	{

	case VK_DESCRIPTOR_TYPE_SAMPLER:
		return SE_DESCRIPTOR_TYPE_SAMPLER;
	case VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER:
		return SE_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER;
	case VK_DESCRIPTOR_TYPE_SAMPLED_IMAGE:
		return SE_DESCRIPTOR_TYPE_SAMPLED_IMAGE;
	case VK_DESCRIPTOR_TYPE_STORAGE_IMAGE:
		return SE_DESCRIPTOR_TYPE_STORAGE_IMAGE;
	case VK_DESCRIPTOR_TYPE_UNIFORM_TEXEL_BUFFER:
		return SE_DESCRIPTOR_TYPE_UNIFORM_TEXEL_BUFFER;
	case VK_DESCRIPTOR_TYPE_STORAGE_TEXEL_BUFFER:
		return SE_DESCRIPTOR_TYPE_STORAGE_TEXEL_BUFFER;
	case VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER:
		return SE_DESCRIPTOR_TYPE_UNIFORM_BUFFER;
	case VK_DESCRIPTOR_TYPE_STORAGE_BUFFER:
		return SE_DESCRIPTOR_TYPE_STORAGE_BUFFER;
	case VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER_DYNAMIC:
		return SE_DESCRIPTOR_TYPE_UNIFORM_BUFFER_DYNAMIC;
	case VK_DESCRIPTOR_TYPE_STORAGE_BUFFER_DYNAMIC:
		return SE_DESCRIPTOR_TYPE_STORAGE_BUFFER_DYNAMIC;
	case VK_DESCRIPTOR_TYPE_INPUT_ATTACHMENT:
		return SE_DESCRIPTOR_TYPE_INPUT_ATTACHMENT;
#ifdef USE_EXTENSIONS
	case VK_DESCRIPTOR_TYPE_INLINE_UNIFORM_BLOCK_EXT:
		return SE_DESCRIPTOR_TYPE_INLINE_UNIFORM_BLOCK_EXT;
	case VK_DESCRIPTOR_TYPE_ACCELERATION_STRUCTURE_NV:
		return SE_DESCRIPTOR_TYPE_ACCELERATION_STRUCTURE_NV;
#endif
	default:
		break;
	}
	return SE_DESCRIPTOR_TYPE_MAX_ENUM;
}

VkShaderStageFlagBits cast(const Seele::Gfx::SeShaderStageFlagBits& stage)
{
	switch (stage)
	{

	case SE_SHADER_STAGE_VERTEX_BIT:
		return VK_SHADER_STAGE_VERTEX_BIT;
	case SE_SHADER_STAGE_TESSELLATION_CONTROL_BIT:
		return VK_SHADER_STAGE_TESSELLATION_CONTROL_BIT;
	case SE_SHADER_STAGE_TESSELLATION_EVALUATION_BIT:
		return VK_SHADER_STAGE_TESSELLATION_EVALUATION_BIT;
	case SE_SHADER_STAGE_GEOMETRY_BIT:
		return VK_SHADER_STAGE_GEOMETRY_BIT;
	case SE_SHADER_STAGE_FRAGMENT_BIT:
		return VK_SHADER_STAGE_FRAGMENT_BIT;
	case SE_SHADER_STAGE_COMPUTE_BIT:
		return VK_SHADER_STAGE_COMPUTE_BIT;
	case SE_SHADER_STAGE_ALL_GRAPHICS:
		return VK_SHADER_STAGE_ALL_GRAPHICS;
	case SE_SHADER_STAGE_ALL:
		return VK_SHADER_STAGE_ALL;
#ifdef USE_EXTENSIONS
	case SE_SHADER_STAGE_RAYGEN_BIT_NV:
		return VK_SHADER_STAGE_RAYGEN_BIT_NV;
	case SE_SHADER_STAGE_ANY_HIT_BIT_NV:
		return VK_SHADER_STAGE_ANY_HIT_BIT_NV;
	case SE_SHADER_STAGE_CLOSEST_HIT_BIT_NV:
		return VK_SHADER_STAGE_CLOSEST_HIT_BIT_NV;
	case SE_SHADER_STAGE_MISS_BIT_NV:
		return VK_SHADER_STAGE_MISS_BIT_NV;
	case SE_SHADER_STAGE_INTERSECTION_BIT_NV:
		return VK_SHADER_STAGE_INTERSECTION_BIT_NV;
	case SE_SHADER_STAGE_CALLABLE_BIT_NV:
		return VK_SHADER_STAGE_CALLABLE_BIT_NV;
	case SE_SHADER_STAGE_TASK_BIT_NV:
		return VK_SHADER_STAGE_TASK_BIT_NV;
	case SE_SHADER_STAGE_MESH_BIT_NV:
		return VK_SHADER_STAGE_MESH_BIT_NV;
#endif
	default:
		break;
	}
	return VK_SHADER_STAGE_ALL;
}

Seele::Gfx::SeShaderStageFlagBits cast(const VkShaderStageFlagBits& stage)
{
	switch (stage)
	{
	case VK_SHADER_STAGE_VERTEX_BIT:
		return SE_SHADER_STAGE_VERTEX_BIT;
	case VK_SHADER_STAGE_TESSELLATION_CONTROL_BIT:
		return SE_SHADER_STAGE_TESSELLATION_CONTROL_BIT;
	case VK_SHADER_STAGE_TESSELLATION_EVALUATION_BIT:
		return SE_SHADER_STAGE_TESSELLATION_EVALUATION_BIT;
	case VK_SHADER_STAGE_GEOMETRY_BIT:
		return SE_SHADER_STAGE_GEOMETRY_BIT;
	case VK_SHADER_STAGE_FRAGMENT_BIT:
		return SE_SHADER_STAGE_FRAGMENT_BIT;
	case VK_SHADER_STAGE_COMPUTE_BIT:
		return SE_SHADER_STAGE_COMPUTE_BIT;
	case VK_SHADER_STAGE_ALL_GRAPHICS:
		return SE_SHADER_STAGE_ALL_GRAPHICS;
	case VK_SHADER_STAGE_ALL:
		return SE_SHADER_STAGE_ALL;
#ifdef USE_EXTENSIONS
	case VK_SHADER_STAGE_RAYGEN_BIT_NV:
		return SE_SHADER_STAGE_RAYGEN_BIT_NV;
	case VK_SHADER_STAGE_ANY_HIT_BIT_NV:
		return SE_SHADER_STAGE_ANY_HIT_BIT_NV;
	case VK_SHADER_STAGE_CLOSEST_HIT_BIT_NV:
		return SE_SHADER_STAGE_CLOSEST_HIT_BIT_NV;
	case VK_SHADER_STAGE_MISS_BIT_NV:
		return SE_SHADER_STAGE_MISS_BIT_NV;
	case VK_SHADER_STAGE_INTERSECTION_BIT_NV:
		return SE_SHADER_STAGE_INTERSECTION_BIT_NV;
	case VK_SHADER_STAGE_CALLABLE_BIT_NV:
		return SE_SHADER_STAGE_CALLABLE_BIT_NV;
	case VK_SHADER_STAGE_TASK_BIT_NV:
		return SE_SHADER_STAGE_TASK_BIT_NV;
	case VK_SHADER_STAGE_MESH_BIT_NV:
		return SE_SHADER_STAGE_MESH_BIT_NV;
#endif	
	default:
		break;
	}
	return SE_SHADER_STAGE_ALL;
}
