#version 450
#extension GL_EXT_mesh_shader : require
#extension GL_EXT_shader_8bit_storage : require
#extension GL_EXT_shader_explicit_arithmetic_types : require
layout(row_major) uniform;
layout(row_major) buffer;

#line 1 0
struct InstanceData_0
{
    mat4x4 transformMatrix_0;
};


#line 46 1
layout(std430, binding = 0, set = 2) readonly buffer StructuredBuffer_InstanceData_t_0 {
    InstanceData_0 _data[];
} scene_instances_0;

#line 1 2
struct MeshletDescription_0
{
    uint vertexCount_0;
    uint primitiveCount_0;
    uint vertexOffset_0;
    uint primitiveOffset_0;
};


#line 47 1
layout(std430, binding = 0, set = 1) readonly buffer StructuredBuffer_MeshletDescription_t_0 {
    MeshletDescription_0 _data[];
} meshlets_meshletInfos_0;

#line 9 2
layout(std430, binding = 1, set = 1) readonly buffer StructuredBuffer_uint8_t_0 {
    uint8_t _data[];
} meshlets_primitiveIndices_0;

#line 9
layout(std430, binding = 2, set = 1) readonly buffer StructuredBuffer_uint_t_0 {
    uint _data[];
} meshlets_vertexIndices_0;

#line 24 3
layout(std430, binding = 0, set = 3) readonly buffer StructuredBuffer_float4_t_0 {
    vec4 _data[];
} vertexData_positions_0;

#line 24
layout(std430, binding = 1, set = 3) readonly buffer StructuredBuffer_float2_t_0 {
    vec2 _data[];
} vertexData_texCoords_0;

#line 24
layout(std430, binding = 2, set = 3) readonly buffer StructuredBuffer_float3_t_0 {
    vec3 _data[];
} vertexData_normals_0;

#line 5 4
struct ViewParameter_0
{
    mat4x4 viewMatrix_0;
    mat4x4 projectionMatrix_0;
    vec4 cameraPos_WS_0;
    vec2 screenDimensions_0;
};

layout(binding = 0)
layout(std140) uniform _S1
{
    mat4x4 viewMatrix_0;
    mat4x4 projectionMatrix_0;
    vec4 cameraPos_WS_0;
    vec2 screenDimensions_0;
}viewParams_0;

#line 24 1

uint gs_numVertices_0_init()
{

#line 24
    return 0U;
}
shared uint gs_numVertices_0 = gs_numVertices_0_init();


#line 5 3
struct StaticMeshVertexAttributes_0
{
    vec4 position_0;
    vec2 texCoords_0;
    vec3 normal_0;
};


#line 22 1
shared StaticMeshVertexAttributes_0  gs_vertices_0[64];



uint gs_numPrimitives_0_init()
{

#line 25
    return 0U;
}
shared uint gs_numPrimitives_0 = gs_numPrimitives_0_init();


#line 23
shared uvec3  gs_indices_0[126];


#line 11
struct MeshShaderPayload_0
{
    uint instanceId_0;
    uint meshletId_0;
};


#line 20 3
StaticMeshVertexAttributes_0 StaticMeshVertexData_getAttributes_0(uint _S2, InstanceData_0 _S3)
{

#line 28
    StaticMeshVertexAttributes_0 attr_0;



    attr_0.position_0 = (((((((((vertexData_positions_0._data[_S2]) * (_S3.transformMatrix_0)))) * (viewParams_0.viewMatrix_0)))) * (viewParams_0.projectionMatrix_0)));
    attr_0.texCoords_0 = vertexData_texCoords_0._data[_S2];
    attr_0.normal_0 = vertexData_normals_0._data[_S2];
    return attr_0;
}


#line 39 1
layout(local_size_x = 32, local_size_y = 1, local_size_z = 1) in;
layout(max_vertices = 64) out;
layout(max_primitives = 126) out;
layout(triangles) out;
void main()
{

#line 39
    MeshShaderPayload_0 p_0;

#line 46
    InstanceData_0 _S4 = scene_instances_0._data[p_0.instanceId_0];
    MeshletDescription_0 _S5 = meshlets_meshletInfos_0._data[p_0.meshletId_0];



    uint _S6 = uvec3(gl_LocalInvocationIndex).x;
    uint _S7 = _S5.vertexCount_0 - 1U;

#line 64
    uint _S8 = _S5.primitiveCount_0 - 1U;

#line 64
    uint loop_0 = 0U;

#line 64
    for(;;)
    {

#line 52
        uint v_0 = min(_S6 + loop_0 * 32U, _S7);
        atomicMax((gs_numVertices_0), (v_0 + 1U));


        gs_vertices_0[v_0] = StaticMeshVertexData_getAttributes_0(uint(int(meshlets_vertexIndices_0._data[_S5.vertexOffset_0 + v_0])), _S4);

#line 49
        uint loop_1 = loop_0 + 1U;

#line 49
        if(loop_1 < 2U)
        {
        }
        else
        {

#line 49
            break;
        }

#line 49
        loop_0 = loop_1;

#line 49
    }

#line 49
    loop_0 = 0U;

#line 49
    for(;;)
    {

#line 64
        uint p_1 = min(_S6 + loop_0 * 32U, _S8);
        atomicMax((gs_numPrimitives_0), (p_1 + 1U));

        uint _S9 = p_1 * 3U;

#line 67
        uint _S10 = _S5.primitiveOffset_0 + _S9;



        uint idx1_0 = meshlets_vertexIndices_0._data[_S5.vertexOffset_0 + uint(meshlets_primitiveIndices_0._data[_S10 + 1U])];
        uint idx2_0 = meshlets_vertexIndices_0._data[_S5.vertexOffset_0 + uint(meshlets_primitiveIndices_0._data[_S10 + 2U])];
        gs_indices_0[_S9] = uvec3(meshlets_vertexIndices_0._data[_S5.vertexOffset_0 + uint(meshlets_primitiveIndices_0._data[_S10])]);
        gs_indices_0[_S9 + 1U] = uvec3(idx1_0);
        gs_indices_0[_S9 + 2U] = uvec3(idx2_0);

#line 61
        uint loop_2 = loop_0 + 1U;

#line 61
        if(loop_2 < 4U)
        {
        }
        else
        {

#line 61
            break;
        }

#line 61
        loop_0 = loop_2;

#line 61
    }

#line 78
    barrier();
    SetMeshOutputsEXT(gs_numVertices_0, gs_numPrimitives_0);
    barrier();

#line 93
    return;
}

